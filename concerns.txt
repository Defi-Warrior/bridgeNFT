Miscellaneous
+ Build an exchange and a general bridge
+ Both From/ToTrader are EOAs => not online at the same time => need DB?
+ Fee: seperate with From/ToAssets
+   Same Id, nonce fromBridge, <	=> safe by check acquired, conflict fromAssets
    Same Id, nonce fromBridge, >	=> safe by check acquired
    Same Id, nonce toBridge, <		=> safe by check acquired, conflict fromAssets
    Same Id, nonce toBridge, >		=> safe by check acquired
    Diff Id, nonce fromBridge, <	=> safe by conflict fromAssets
    Diff Id, nonce fromBridge, >	=> double speding risk
    Diff Id, nonce toBridge, <		=> safe by conflict fromAssets
    Diff Id, nonce toBridge, >		=> double speding risk
    (Check acquired: mark trade done former half by tradeId)
+ Upgrade to OpenZeppelin 4.8
+ Not encode data structure sent to operator to support EIP712 (may be diff in bridge)
- Full script
- Collusion among 4 parties (2 traders, validator, marketplace) against one actor
- Imagine UI/UX

On-chain general
+ Account roles:
    configManagingAuthority, hasherAdder, signatureVerifierAdder, proofVerifierAdder, processorAdder, validatingAuthority -> revokingAuthority, appointingAuthority
    stopper, pauser, unpauser
    * Authority { members[], signatureVerifierId }
    * Change validatingAuthority/revokingAuthority/appointingAuthority -> pause entire system
+ Contract roles:
    AC: operator(2), hasherRegistry(1), signatureVerifierRegistry(1), proofVerifierRegistry(1), processorProxy(1) -> admin(1)
    No AC:
        tradeIdHasher(1), tradeHasher -> hasherRegistry
        signatureVerifier -> signatureVerifierRegistry
        proofVerifier -> proofVerifierRegistry
        database(3),
        processor -> processorProxy
+ tradeHasherId, signatureVerifierId, proofVerifierId, processorId must be consistent across all chains
+ Trader is contract => delegate to other accounts / validator acts on behalf
+ Map of actors
+ _globalWaitingDurationForOldTokenToBeProcessed => mapping for each chain
+ 3 signature format
+ Mint-then-burn => not a bug
+ Check if address 0 when decode from control data
+ Validator Revocation -> observer pattern
+ Use seperate admin contract for access control
+ Restrict call to processorProxy, store to database to be originated only from operator
+ Rewrite EnumerableMap
+ Same chain -> 1 tx
+ Diff chain -> hash data for the other chain
+ Exchange's CALL restrict on function signature and callee address.
+ External call incurs 1 copy action for calldata, 2 copy actions for memory -> try to use calldata, reduce external call if possible
+ Require latterTradeNotValidAfter - formerTradeNotValidAfter > some preset value to allow time for the latter
+ Require source address in transferFrom diff from processor's address

+ Use inheritance to seperate & choose which component to make dynamic
+ Dynamic component: string id -> uint256 id + json string description
+ Make commitment scheme dynamic & public => commitment -> statement, secret -> proof
+ Make hasher & signature verifier on hash dynamic & public
+ TradeId hash is fix, do not make dynamic -> tradeId := keccak256(formerExchangeChainId || formerExchange || traderA XOR traderB || tradeNonce)
+ Delegate hash to tradeId to static public TradeIdHasher contract, do not use EIP712
+ Make distributor dynamic
+ Make processor dynamic
+ eip712 restrict signature on 1 chain -> use 2 signatures for 2 chains -> 6 signatures total
+ Make DB dynamic -> No, 3 fixed databases
+ BLS threshold technique
+ Send another signature as proof of approval when minting -> send mintApprover's address

- What to store, to emit?
- Store block number of request in contract storage for search
- From/ToChainId, From/ToBridge duplicate
- Divide & reduce redundant fields in DB
- Ignore validator's signature, proof if same chain?
- Support tryTrade view function (check requirements without transfer/lock)

FormerTradeOperator
+ Emit tradeHash (because of stateless validator)
+ Store nonce here in order not to block future trade between same trader pair

LatterTradeOperator
+ Lock assets that only allow one tradeId to acquire
+ Make isAcquired, isDenied functions public, add isFinished function = isAcquired || isDenied
+ Change from commitment to tradeId for id
+ Restrict same chain exchange call to be only from FormerTradeOperator
- Support lock for exchange
- Require diff chain when lock

Off-chain general
- MEV attack (node trust)

Validator
+ secret <- PRF(tradeId) => secret <- PRF(tradeHash)
+ Not allow trade valid forever to rotate secret generating key
- Reveal signature after or before seeing traders'? Sign including raders' sigs?
- Could vadiator delegate to another to perform FormerTrade?

Trader
